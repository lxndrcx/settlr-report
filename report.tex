\documentclass[a4paper]{article}
\usepackage[a4paper,margin=3.5cm]{geometry}

\title{
  Runtime Verification using Four Valued Timed Propositional Temporal Logic\\
  \normalsize{} COMP4560 Report
}
\author{
  Alexander Cox
  \thanks{Studying a Bachelor of Science at The Australian National University (ANU)}\\
  \small\texttt{u6060697@anu.edu.au}\\
  \normalsize{}Supervised by Professor Peter Baumgartner\thanks{Data61, CSIRO\@; ANU}
}

\usepackage{parskip}

\usepackage[backend=biber, style=numeric-comp]{biblatex}
\addbibresource{report.bib}

\usepackage{mathtools}
\usepackage{amsthm, amssymb}
\usepackage{thmtools, thm-restate}
\declaretheorem[numberwithin=subsection,name=Theorem]{thm}
\declaretheorem[sibling=thm,name=Lemma]{lem}
\declaretheorem[sibling=thm,name=Corollary]{corl}
\declaretheorem[sibling=thm,style=definition,name=Definition]{defn}
\declaretheorem[sibling=thm,style=remark,name=Notation]{notn}
\declaretheorem[sibling=thm,style=remark,name=Remark]{remk}
\usepackage{alltt}
\usepackage{hyperref}

\newcommand{\U}{\mathsf{U}}
\newcommand{\tand}{\text{ and }}
\newcommand{\tor}{\text{ or }}
\newcommand{\fsome}{\text{ for some }}
\newcommand{\fall}{\text{ for all }}

\begin{document}
\maketitle

\begin{abstract}
\end{abstract}
\newpage

\section{Introduction}
\subsection{Runtime Verification}
Runtime verification~\autocite{colin2005rv} is a method of monitoring a system and checking whether it satisfies (or violates) a correctness property.
The properties of runtime verification are temporal properties, and are often specified in a temporal logic. % TODO example

Runtime verification is closely related to model checking~\autocite{baier2008principles}. Model checking is concerned with verifying all possible runs of a system, by means of a model of that system. In runtime verification we are concerned only with real world runs of a system, with the system not modeled, but monitored. In model checking the system has infinite runs, whereas in runtime verification, runs are finite.

\section{Temporal Logic}
In this project, our correctness properties are expressed using a temporal logic, i.e., a modal logic which can be used to reason about time. All of the logics I will discuss are based on Linear Temporal Logic.

\subsection{Linear Temporal Logic}
Linear Temporal Logic (LTL)\autocite{pnueli1977temporal} is a temporal logic created for model checking. It's syntax and semantics follow. Assume that we have an infinite supply of propositional variables $a,b,c,\dots$.
\begin{defn}{LTL Syntax}

  An LTL formula $\varphi$ is inductively defined in as follows\footnote{In Bachus-Naur form}:
  \[\varphi ::= a ~|~ \bot ~|~ \neg \varphi ~|~\varphi \lor \varphi ~|~ \varphi \land \varphi ~|~ \bigcirc \varphi ~|~ \varphi \U\varphi\]
\end{defn}
\begin{notn}{LTL Abbreviations}

  The following standard abbreviations are made:
  \begin{align*}
    \top &:= \neg \bot\\
    \varphi \to \psi &:= \neg \varphi \lor \psi\\
    \varphi \leftrightarrow \psi &:= (\varphi \to \psi) \land (\psi \to \varphi)\\
    \Diamond \varphi &:= \top \U{} \varphi\\
    \Box \varphi &:= \neg\Diamond\neg\varphi
  \end{align*}
\end{notn}

We read $\top$ as `true', $\bot$ as `false', $\bigcirc$ as `next', $\Diamond$ as `eventually', $\Box$ as `always', and $\U$ as `until'.

The formulae of LTL are interpreted over sequences of states called traces.

\begin{defn}{Traces and states}

  Let $P$ be a set of propositional variables. A \emph{state} $\rho_i \subseteq P$ is a set of propositional variables which are interpreted as true. A \emph{trace} $\sigma \in P^+$ is an infinite sequence of states.
\end{defn}

\begin{notn}
Let $\sigma$ be a sequence, then $\sigma_i$ is the $i$th state in $\sigma$ and $\sigma^i$ is $\sigma$ with the first $i$ elements removed.
\end{notn}

\begin{defn}{LTL Semantics}

  Let $P$ be a set of propositional variables and $\sigma$ a trace. The satisfaction relation $\vDash$ is inductively defined as follows:
\begin{align*}
  \sigma &\vDash a \iff a \in \sigma_0\\
  \sigma &\nvDash \bot\\
  \sigma &\vDash \neg \varphi \iff \sigma \nvDash \varphi\\
  \sigma &\vDash \varphi \lor \psi \iff \sigma \vDash \varphi \tor \sigma \vDash \psi\\
  \sigma &\vDash \varphi \land \psi \iff \sigma \vDash \varphi \tand \sigma \vDash \psi\\
  \sigma &\vDash \bigcirc \varphi \iff \sigma^1 \vDash \varphi\\
  \sigma &\vDash \varphi \U \psi \iff \sigma^i \vDash \psi \fsome i \geq 0 \tand \sigma^j \vDash \varphi \fall 0 \leq j < i
\end{align*}

\end{defn}

\subsection{Timed Propositional Temporal Logic}
\begin{defn}{Timed Trace}

  A Timed Trace $\rho = (\sigma,\tau)$ is a pair of a trace (state sequence) $\sigma \in P^+$ and a time sequence $\tau \in \mathbb{N}^+$ which is a sequence of non-negative integers that is monotonically non-decreasing ($\forall i. ~\tau_i \leq \tau_{i+1}$) and eventually always increasing ($\forall i. \exists j. ~\tau_i < \tau_j$).
\end{defn}

Assume there exist an infinite supply of time variables  and let $V=\{x,y,z...\}$ be the set of these variables.

\begin{defn}{TPTL Syntax}
  Let $a\in P$ be a propositional variable, $x\in V$ be a time variable and $c\in\mathbb{N}$ a constant.

  TPTL terms $\pi$ and formulas $\varphi$ are inductively defined as follows:
  \begin{align*}
    \pi &::= x + c ~|~ c\\
    \varphi &::= a ~|~ \pi \leq \pi ~|~ \bot ~|~ \neg \varphi ~|~\varphi \lor \varphi ~|~ \varphi \land \varphi ~|~ \bigcirc \varphi ~|~ \varphi \U \varphi ~|~ x. \varphi
  \end{align*}
\end{defn}

\begin{notn}{Abbreviations}

  TPTL has the same abbreviations as LTL, plus abbreviations for comparison operations between terms such as $\pi_1 < \pi_2 := \pi_1 \leq \pi_2 \land \neg(\pi_2 \leq \pi_1)$, and so on as expected for $>,\geq,=,\neq$.
\end{notn}

\begin{defn}{PTPL Semantics}
  \newcommand{\eval}{\mathcal{E}}
  Let $\rho = (\sigma,\tau)$ be a time trace, and let $\eval:V\to\mathbb{N}$ be a evaluation of time variables to times, with $\eval(x + c) = \eval(x) + c$, $\eval(c) = c$ and $\eval[x:=c]$ denoting the evaluation which agrees with $\eval$ for $V\setminus\{x\}$ and maps $x$ to $c$.
  PTPL has the only slightly modified semantics for the fragment which overlaps with LTL. For those cases, just substitute occurrences of $\sigma\vDash$ with $\rho\vDash$. The remainder of the definition is as follows.
  \begin{align*}
    \rho\vDash
  \end{align*}
\end{defn}


\subsection{Finite LTL}
\subsection{Finite TPTL}
\subsection{RV-TPTL}
\section{Runtime Verification using Formula Rewriting}
\section{Implementation in Scala}
%shallow embedding / internal DSL ref TraceContract

\section{Discussion}
\subsection{Future Work}
\section{Conclusion}
\subsection{Acknowledgements}

\nocite{*}
\printbibliography{}
\newpage
\section{Appendix}\label{appendix}

\end{document}
