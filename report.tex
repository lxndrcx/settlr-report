\documentclass[a4paper]{article}
\usepackage[a4paper,margin=3.5cm]{geometry}

\title{
  Four Valued Timed Propositional Temporal Logic for Runtime Verification\\
  \normalsize{} COMP4560 Report
}
\author{
  Alexander Cox
  \thanks{Studying a Bachelor of Science at The Australian National University (ANU)}\\
  \small\texttt{u6060697@anu.edu.au}\\
  \normalsize{}Supervised by Professor Peter Baumgartner\thanks{Data61, CSIRO\@; ANU}
}

\usepackage{parskip}

\usepackage[backend=biber, style=alphabetic]{biblatex}
\addbibresource{report.bib}

\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{amsthm}
% \numberwithin{equation}{subsection}
\usepackage{thmtools, thm-restate}
\usepackage{nameref, hyperref, cleveref}
% \usepackage[nothm]{thmbox}
\declaretheorem[numberwithin=subsection,name=Theorem]{thm}
\declaretheorem[sibling=thm,name=Lemma]{lem}
\declaretheorem[sibling=thm,name=Corollary]{corl}
\declaretheorem[sibling=thm,style=definition,name=Definition]{defn}
\declaretheorem[sibling=thm,style=remark,name=Notation]{notn}
\declaretheorem[sibling=thm,style=remark,name=Remark]{remk}
\declaretheorem[sibling=thm,style=remark,name=Example]{eg}
\usepackage{mdframed}
\mdfsetup{linewidth=1pt,rightline=false,bottomline=false,skipabove=\topskip}
\surroundwithmdframed{thm}
\surroundwithmdframed{lem}
\surroundwithmdframed{corl}
\surroundwithmdframed{defn}
\surroundwithmdframed{eg}
\surroundwithmdframed{remk}
\surroundwithmdframed{notn}

\setcounter{secnumdepth}{2}
\usepackage{alltt}
\usepackage{hyperref}

\newcommand{\U}{\mathsf{U}}
\newcommand{\tand}{\text{ and }}
\newcommand{\tor}{\text{ or }}
\newcommand{\tiff}{\text{ iff }}
\newcommand{\fsome}{\text{ for some }}
\newcommand{\fall}{\text{ for all }}
\newcommand{\sn}{\bigcirc^+}
\newcommand{\wn}{\bigcirc^-}
\newcommand{\eval}{\mathcal{E}}
\newcommand{\ltlt}{LTL$_3$}
\newcommand{\rw}[1]{\Rightarrow_{#1}}
\begin{document}
\maketitle

\begin{abstract}
\end{abstract}
\newpage
\tableofcontents
% \newpage

\section{Introduction}
\subsection{Runtime Verification}
Runtime verification~\autocite{colin2005rv} is a method of monitoring a system and checking whether it satisfies (or violates) a correctness property.
The properties of runtime verification are temporal properties, and are often specified in a temporal logic. % TODO example

Runtime verification is closely related to model checking~\autocite{baier2008principles}. Model checking is concerned with verifying all possible runs of a system, by means of a model of that system. In runtime verification we are concerned only with real world runs of a system, with the system not modeled, but monitored. In model checking each run of the system is infinite, whereas in runtime verification, runs are always a finite prefix of an infinite run, even if the system runs forever.

% TODO why is my project important

\section{Temporal Logic}
In this project, our correctness properties are expressed using a temporal logic, i.e., a modal logic which can be used to reason about time. All of the logics I will discuss are based on Linear Temporal Logic.

% TODO more words

\subsection{Linear Temporal Logic}
Linear Temporal Logic (LTL)\autocite{pnueli1977temporal} is a temporal logic created for model checking. It's syntax and semantics follow. Assume that we have an infinite supply of propositional variables $a,b,c,\dots$.
\begin{defn}{LTL Syntax}

  An LTL formula $\varphi$ is inductively defined in as follows\footnote{In Bachus-Naur form}:
  \[\varphi ::= a ~|~ \bot ~|~ \neg \varphi ~|~\varphi \lor \varphi ~|~ \bigcirc \varphi ~|~ \varphi \U\varphi\]
\end{defn}
\begin{notn}{LTL Abbreviations}

  The following standard abbreviations are made:
  \begin{align*}
    \top &:= \neg \bot\\
    \varphi \to \psi &:= \neg \varphi \lor \psi\\
    \varphi \land \psi &:= \neg (\neg \varphi \lor \neg \psi)\\
    \varphi \leftrightarrow \psi &:= (\varphi \to \psi) \land (\psi \to \varphi)\\
    \Diamond \varphi &:= \top \U{} \varphi\\
    \Box \varphi &:= \neg\Diamond\neg\varphi
  \end{align*}
\end{notn}

We read $\top$ as `true', $\bot$ as `false', $\bigcirc$ as `next', $\Diamond$ as `eventually', $\Box$ as `always', and $\U$ as `until'.

The formulae of LTL are interpreted over sequences of states called traces.

\begin{defn}{Traces and states}

  Let $P$ be a set of propositional variables. A \emph{state} $\rho_i \subseteq P$ is a set of propositional variables which are interpreted as true. A \emph{trace} $\sigma \in P^+$ is an infinite sequence of states.
\end{defn}

\begin{notn}
Let $\sigma$ be a sequence, then $\sigma_i$ is the $i$th state in $\sigma$, $\sigma^i$ is $\sigma$ with the first $i$ elements removed, and $\epsilon$ is the empty sequence.
\end{notn}

\begin{defn}{LTL Semantics}\label{ltlsem}

  Let $P$ be a set of propositional variables and $\sigma$ a trace. The satisfaction relation $\vDash_{LTL}$ is inductively defined as follows:
\begin{align*}
  \sigma &\vDash_{LTL} a \tiff a \in \sigma_0\\
  \sigma &\nvDash_{LTL} \bot\\
  \sigma &\vDash_{LTL} \neg \varphi \tiff \sigma \nvDash_{LTL} \varphi\\
  \sigma &\vDash_{LTL} \varphi \lor \psi \tiff \sigma \vDash_{LTL} \varphi \tor \sigma \vDash_{LTL} \psi\\
  \sigma &\vDash_{LTL} \varphi \land \psi \tiff \sigma \vDash_{LTL} \varphi \tand \sigma \vDash_{LTL} \psi\\
  \sigma &\vDash_{LTL} \bigcirc \varphi \tiff \sigma^1 \vDash_{LTL} \varphi\\
  \sigma &\vDash_{LTL} \varphi \U \psi \tiff \sigma^i \vDash_{LTL} \psi \fsome i \geq 0 \tand \sigma^j \vDash_{LTL} \varphi \fall 0 \leq j < i
\end{align*}

\end{defn}

\begin{lem}{Expansion laws}\label{ltlexp}

  In LTL, the following equivalences hold:
  \begin{align}
    \Box \varphi &\equiv \varphi \land \bigcirc \Box \varphi\label{elbox}\\
    \Diamond \varphi &\equiv \varphi \lor \bigcirc \Diamond \varphi\label{eldiamond}\\
    \psi \U \varphi &\equiv \varphi \lor \bigcirc \psi \U \varphi\label{elU}
  \end{align}

\end{lem}

% TODO Examples


\subsection{Finite LTL}
For runtime verification, we are generally concerned with finite traces. Since LTL is defined over infinite traces, a modification of the semantics is necessary to apply it to runtime verification problems. %TODO give good reasons
There are several variations of finite LTL semantics, I will consider Infinite Extension LTL (IE-LTL)~\autocite{rosu2005rewriting}, RV-LTL~\autocite{bauer2010comparing} and the two logics which RV-LTL is based upon, FLTL and LTL$_3$~\autocite{bauer2010comparing}.
Assume that each trace $\sigma$ in this section is finite.

\subsubsection{IE-LTL} The idea behind IE-LTL is to assume that the final state of a trace repeats forever. For IE-LTL, the only difference in the semantics is in the final state.
\begin{defn}{IE-LTL semantics}

  Let $\sigma_f$ be the final state of the trace. Copy the semantics from the LTL semantics \Cref{ltlsem}, and add the following to them:
  \begin{align*}
    \sigma_f &\vDash_{IELTL} \bigcirc \varphi \tiff \sigma_f \vDash_{IELTL} \varphi\\
    \sigma_f &\vDash_{IELTL} \varphi \U \psi \tiff \sigma_f \vDash_{IELTL} \psi
  \end{align*}
\end{defn}


\subsubsection{FLTL} For FLTL, the next operator of LTL is split into a weak ($\wn$) and strong ($\sn$) version.
The strong next requires the existence of a next state to be true, while the weak next operator is vacuously true if there is no next state.
Thus, in the final state, the weak operator evaluates to true, and the strong next to false. The strong and weak next operators are dual of each other, with  $\neg\sn\varphi \equiv \wn\neg\varphi$.

\begin{defn}{FLTL semantics}

  Copy the standard LTL semantics in \Cref{ltlsem}, and replace the rule for the next operator with:
  \begin{align*}
    \sigma&\vDash_{FLTL}\sn\varphi \tiff \sigma^1\vDash_{FLTL}\varphi \tand \sigma^1 \neq \epsilon\\
    \sigma&\vDash_{FLTL}\wn\varphi \tiff \sigma^1\vDash_{FLTL}\varphi \tor \sigma^1 = \epsilon
  \end{align*}
\end{defn}

\begin{lem}{Expansion Laws for FLTL}\label{fltlexp}

  In FLTL, the following expansion laws are equivalences:
  \begin{align}
    \Box \varphi \equiv \varphi \land \wn \Box \varphi \label{felBox}\\
    \Diamond \varphi \equiv \varphi \lor \sn \Diamond \varphi\label{felDiamond}\\
    \psi \U \varphi \equiv \varphi \lor \sn \psi \U \varphi\label{felU}
  \end{align}

\end{lem}

\begin{proof}
  (From \autocite{bauer2010comparing}.)
  %Bauer 5.3
\end{proof}

\subsubsection{\ltlt} In \ltlt, a new truth value is introduced to represent uncertainty.

\begin{defn}{\ltlt\ semantics}

  The semantics for \ltlt\ are defined by cases relying on standard LTL semantics. The notation $\sigma\gamma$ refers to the concatenation of the infinite trace $\gamma$ to the finite trace $\sigma$.
  \[\sigma\vDash_{LTL_3}\varphi =
    \begin{cases}
      \top & \text{if } \sigma\gamma \vDash{LTL} \varphi \fall \gamma \in P^+\\
      \bot & \text{if } \sigma\gamma \vDash{LTL} \varphi \fall \gamma \in P^+\\
      ? & \text{otherwise}
    \end{cases}
    \]
\end{defn}

\subsubsection{RV-LTL} RV-LTL is based on FLTL and \ltlt.

\begin{defn}{RV-LTL semantics}

  The semantics for RV-LTL are also defined by cases.
  \[\sigma\vDash_{RVLTL}\varphi =
    \begin{cases}
      \top & \text{if } \sigma \vDash_{LTL_3} \varphi = \top\\
      \bot & \text{if } \sigma \vDash_{LTL_3} \varphi = \bot\\
      \top^P & \text{if } \sigma \vDash_{LTL_3} \varphi = ~?\tand \sigma\vDash_{FLTL} = \top \\
      \bot^P & \text{if } \sigma \vDash_{LTL_3} \varphi = ~?\tand \sigma\vDash_{FLTL} = \bot \\

    \end{cases}
  \]
\end{defn}


\subsection{Timed Propositional Temporal Logic}
Timed Propositional Temporal Logic (TPTL)\autocite{alur1994really} is an extension of LTL to encode explicit time into the logic. In LTL, only the order of states is reasoned about, i.e., $\sigma_i$ is before $\sigma_{i+1}$, but for many verification problems it can be useful to reason about the explicit time at which a state occurs, i.e., $\sigma_i$ is 3 time units earlier than $\sigma_{i+1}$. For this we define a time trace which contains the sequence of times corresponding to the sequence of states. A quantifier called a \emph{freeze operator} is added to the logic, which binds occurrences of a variable to the time at which the operator is evaluated. Integer comparison is added to the logic, to allow for specifications such as: ``If $p$ becomes true, $q$ will become true within 5 time units".

% TODO say how TPTL generalises LTL, thanks Peter


\begin{defn}{Timed Trace}

  A Timed Trace $\rho = (\sigma,\tau)$ is a pair of a trace (state sequence) $\sigma \in P^+$ and a time sequence $\tau \in \mathbb{N}^+$ which is a sequence of non-negative integers that is monotonically non-decreasing ($\forall i. ~\tau_i \leq \tau_{i+1}$) and eventually always increasing ($\forall i. \exists j. ~\tau_i < \tau_j$).
\end{defn}

Assume there exist an infinite supply of time variables  and let $V=\{x,y,z...\}$ be the set of these variables.

\begin{defn}{TPTL Syntax}\label{tptlsyn}
  Let $a\in P$ be a propositional variable, $x\in V$ be a time variable and $c\in\mathbb{N}$ a constant.

  TPTL terms $\pi$ and formulas $\varphi$ are inductively defined as follows:
  \begin{align*}
    \pi &::= x + c ~|~ c\\
    \varphi &::= a ~|~ \pi \leq \pi ~|~ \bot ~|~ \neg \varphi ~|~\varphi \lor \varphi ~|~ \bigcirc \varphi ~|~ \varphi \U \varphi ~|~ x. \varphi
  \end{align*}
\end{defn}

We read $x. \varphi$ as `freeze $x$ in $\varphi$'.

\begin{notn}{Abbreviations}\label{tptlabbrev}

  TPTL has the same abbreviations as LTL, plus abbreviations for comparison operations between terms such as $\pi_1 < \pi_2 := \pi_1 \leq \pi_2 \land \neg(\pi_2 \leq \pi_1)$, and so on as expected for $>,\geq,=,\neq$.
\end{notn}

\begin{defn}{TPTL Semantics}

  Let $\rho = (\sigma,\tau)$ be a time trace, $x\in V$, $c\in\mathbb{N}$, and let $\eval:V\to\mathbb{N}$ be a evaluation of time variables to times, with $\eval(x + c) = \eval(x) + c$, $\eval(c) = c$ and $\eval[x:=c]$ denoting the evaluation which agrees with $\eval$ for $V\setminus\{x\}$ and maps $x$ to $c$.
  TPTL uses the same semantics as LTL for those operators which overlap with LTL, except the relation is defined over a time trace rather than a standard trace. For those cases, substitute occurrences of $\sigma\vDash_{LTL}\cdots$ with $\rho\vDash_{TPTL,\eval}\cdots$. The remainder of the definition is as follows:
  \begin{align*}
    \rho&\vDash_{TPTL,\eval}\pi_1\leq\pi_2 \tiff \eval(\pi_1)\leq\eval(\pi_2)\\
    \rho&\vDash_{TPTL,\eval} x.\varphi \tiff \rho\vDash_{TPTL,\eval[x:=\tau_0]}\varphi
  \end{align*}
\end{defn}

% TODO examples of specifications
\subsection{Finite TPTL}
\subsubsection{RV-TPTL} The following finite semantics for TPTL, which I name RV-TPTL, are a combination of the RV-LTL four valued logic and TPTL. I have not seen this combination elsewhere in the literature, and thus assume it is new. The closest I have seen is the three valued TLTL$_3$~\autocite[6]{arafat2005runtime} which is based on \ltlt\ and TLTL, a different timed temporal logic. The idea is that if RV-LTL is finite LTL + uncertainty and TPTL is LTL + explicit time, then RV-TPTL is finite LTL + uncertainty + explicit time.

\begin{defn}{RV-TPTL Syntax}

  Copy the term syntax from \Cref{tptlsyn} and define the formulas of RV-TPTL as:
  \[\varphi ::= a ~|~ \pi \leq \pi ~|~ \bot ~|~ \bot^P ~|~ \neg \varphi ~|~\varphi \lor \varphi ~|~ \bigcirc \varphi ~|~ \varphi \U \varphi ~|~ x. \varphi
  \]
\end{defn}
\begin{notn}{RV-TPTL abbreviations}

  Take the standard abbreviations for TPTL (\Cref{tptlabbrev}) and add the abbreviation \(\top^P := \neg \bot^P\).
\end{notn}
\begin{defn}{RV-TPTL Semantics}

  I will give the semantics based on TPTL, in cases as RV-LTL was given. Let $\eval:V\to\mathbb{N}$ be a evaluation of time variables to times as in TPTL.
  The notation $\rho\omega$ refers to the concatenation of the infinite time trace $\omega$ to the finite time trace $\rho$.

  Let $\vDash_{T3}$ be given by:
  \[\rho\vDash_{T3}\varphi = \begin{cases}
      \top & \text{if } \rho\omega \vDash_{TPTL,\eval} \varphi \fall \omega \in (P^+,\mathbb{N}^+)\\
      \bot & \text{if }  \rho\omega \vDash_{TPTL,\eval} \varphi \fall \omega \in (P^+,\mathbb{N}^+)\\
      ? & \text{otherwise}
    \end{cases}
  \]

  Let $\vDash_{FT}$ be defined by taking TPTL semantics and adding:
  \begin{align*}
    \rho&\vDash_{FT}\sn\varphi \tiff \rho^1\vDash_{FT}\varphi \tand \rho^1 \neq \epsilon\\
    \rho&\vDash_{FT}\wn\varphi \tiff \rho^1\vDash_{FT}\varphi \tor \rho^1 = \epsilon
  \end{align*}

  Finally, define $\vDash_{RV-TPTL}$, the satisfaction relation for RV-TPTL, by the following:
  \[\rho\vDash_{RV-TPTL}\varphi =
    \begin{cases}
      \top & \text{if } \sigma \vDash_{T3} \varphi = \top\\
      \bot & \text{if } \sigma \vDash_{T3} \varphi = \bot\\
      \top^P & \text{if } \sigma \vDash_{T3} \varphi = ~?\tand \sigma\vDash_{FT} = \top \\
      \bot^P & \text{if } \sigma \vDash_{T3} \varphi = ~?\tand \sigma\vDash_{FT} = \bot
    \end{cases}
  \]
\end{defn}

% TODO maybe include a IE-TPTL?

\section{Runtime Verification using Formula Rewriting}
\subsection{Formula Rewriting}
Formula rewriting~\autocite{rosu2005rewriting}, or formula progression, is a technique used in runtime verification.
The idea is to simplify the formula using the truth values at the current state, then rewrite the formula using the expansion laws, and finally remove the top level $\bigcirc,\sn,\wn$ operators (except in the final state). The resulting formula is true at the next state iff the original formula was true at the original state in the trace.
Each state is consumed in the process, and all relevant information from the past is brought forward in the rewritten formula.

\begin{notn}{Rewrites}

  Let $\rw{\text{S},E}$ denote a formula rewriting step under the logical system S with the state $E$. E.g. $\varphi\rw{\text{RV-LTL},E}\psi$ says that the formula $\varphi$ rewrites to $\psi$ under RV-LTL using the state $E$.
\end{notn}

\begin{eg}{Traffic Lights}

  For a simple example, consider the LTL traffic light example from \textcite[175]{rosu2005rewriting}, with $V=\{r,y,g\}$, $\sigma = (\{g\},\{r\})$ and $\varphi = \Box (g \to (\neg r \U y))$. The trace $\sigma$ should violate the formula. Let $\rw{E}$ stand for $\rw{\text{IE-LTL},E}$ in this example. Here is the progression:
\begin{align}
  \Box (g \to (\neg r \U y)) &\rw{\{g\}} \Box (g \to (\neg r \U y)) \land (\neg r \U y)\label{rw1}\\
  &\rw{\{r\}} \bot\label{rw2}
\end{align}

The rewrite in~\eqref{rw1} uses the expansion law $\Box \varphi \equiv \varphi \land \bigcirc \Box \varphi$ and then rewrites that given that $g$ is true.
Then in~\eqref{rw2} the formula is rewritten to false, since the right conjunct is false given $r$ being true. This is the case whether or not $\{r\}$ is the final state in the trace. If the trace were longer no more of it would need to be validated, all possible suffixes of $\sigma$ violate the formula $\varphi$.
\end{eg}

Let $\rw{E}$ stand for $\rw{\text{RV-TPTL},E}$ for the remainder of the section.

\begin{eg}{Apples}

  For a timed example in RV-TPTL, consider a container of apples which needs to be delivered to a store within a specified time. Let $V=\{sent, received\}$, \(\rho=((\{sent\},\{received\}),(1,4)),\) and \(\varphi=\Box x. (sent \to \Diamond y. (received \land y \leq x + 3)).\)
  The trace $\rho$ will presumably satisfy the formula.
  Here is the progression:
  \begin{align}
    &\Box x. (sent \to \Diamond y. (received \land y \leq x + 3))\nonumber\\
    \rw{\{sent\}}
    &\Box x. (sent \to \Diamond y. (received \land y \leq x + 3))\nonumber\\
    &\land \Diamond y. (received \land y \leq 4)
    \label{eg-apples1}\\
    \rw{\{received\}}
    &(\wn \Box x. (sent \to \Diamond y. (received \land y \leq x + 3))\nonumber\\
    &\land \sn \Diamond y. (received \land y \leq 4))\nonumber\\
    &\lor \wn \Box x. (sent \to \Diamond y. (received \land y \leq x + 3))\label{eg-apples2}\\
    \vDash
    &\top^P\label{eg-apples3}
  \end{align}
  The formula $\varphi$ is rewritten to~\eqref{eg-apples1} using simplification given $\{sent\}$ and the expansion law $\Box \varphi \equiv \varphi \land \wn \Box \varphi$~\eqref{felBox}.
  Then the formula is rewritten to~\eqref{eg-apples2} using the expansions laws~\eqref{felBox} and~\eqref{felDiamond} given $\{received\}$.
  Note that the next operators are not stripped in this last state of the trace.
  Since the end of the trace is reached, we have $(\top^P \land \bot^P) \lor \top^P$ by the semantics of RV-TPTL, which is equivalent to $\top^P$ in~\eqref{eg-apples3}.

  Thus the formula $\varphi$ presumably satisfies the trace $\rho$.
  Adding a finite suffix could change that result, namely if you have a trace where $sent$ is never followed by $received$.
  In this case you would get the result $\bot^P$ instead.

  Note that this formula is only ever satisfied or violated by infinite traces, which is why the uncertainty given by RV-TPTL is plausibly desirable given a finite trace.
\end{eg}

\begin{remk}{Complexity of Formula Rewriting}
\end{remk}

\subsection{Related Work}
Formula rewriting was devised for LTL in \textcite{rosu2005rewriting}, as part of the Java PathExplorer project, and has been used in some NASA programs. The technique was revised for TPTL in \textcite{chai2013rewriting}, with a case study of its potential for use in a train control system. In both of these works, a separate rewrite engine called Maude~\autocite{clavel2002maude} was used. In the next section I discuss the implementation of my rewrite based verification tool, which does not use Maude.

\section{Implementation in Scala}
% shallow embedding / internal DSL ref TraceContract
\subsection{Shallow Embedding}
\subsection{Formula Rewriting}
\subsection{Runtime Verification}

% TODO time abbreviations (free vars)

% TODO complexity better with simp

\section{Discussion}
\subsection{Future Work}
\section{Conclusion}
\subsection{Acknowledgements}

\nocite{*}
\printbibliography{}
\newpage
\section{Appendix}\label{appendix}

\end{document}
