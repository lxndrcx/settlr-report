\documentclass[a4paper]{article}
\usepackage[a4paper,margin=3.5cm]{geometry}

\title{
  Four Valued Timed Propositional Temporal Logic for Runtime Verification\\
  \normalsize{} COMP4560 Report
}
\author{
  Alexander Cox
  \thanks{Studying a Bachelor of Science at The Australian National University (ANU)}\\
  \small\texttt{u6060697@anu.edu.au}\\
  \normalsize{}Supervised by Professor Peter Baumgartner\thanks{Data61, CSIRO\@; ANU}
}

\usepackage{parskip}

\usepackage[backend=biber, style=alphabetic]{biblatex}
\addbibresource{report.bib}

\usepackage{mathtools}
\usepackage{amsthm, amssymb}
\usepackage{thmtools, thm-restate}
\declaretheorem[numberwithin=subsection,name=Theorem]{thm}
\declaretheorem[sibling=thm,name=Lemma]{lem}
\declaretheorem[sibling=thm,name=Corollary]{corl}
\declaretheorem[sibling=thm,style=definition,name=Definition]{defn}
\declaretheorem[sibling=thm,style=remark,name=Notation]{notn}
\declaretheorem[sibling=thm,style=remark,name=Remark]{remk}
\usepackage{alltt}
\usepackage{hyperref}

\newcommand{\U}{\mathsf{U}}
\newcommand{\tand}{\text{ and }}
\newcommand{\tor}{\text{ or }}
\newcommand{\fsome}{\text{ for some }}
\newcommand{\fall}{\text{ for all }}

\begin{document}
\maketitle

\begin{abstract}
\end{abstract}
\newpage
\tableofcontents
\newpage

\section{Introduction}
\subsection{Runtime Verification}
Runtime verification~\autocite{colin2005rv} is a method of monitoring a system and checking whether it satisfies (or violates) a correctness property.
The properties of runtime verification are temporal properties, and are often specified in a temporal logic. % TODO example

Runtime verification is closely related to model checking~\autocite{baier2008principles}. Model checking is concerned with verifying all possible runs of a system, by means of a model of that system. In runtime verification we are concerned only with real world runs of a system, with the system not modeled, but monitored. In model checking the system has infinite runs, whereas in runtime verification, runs are finite.

%TODO why is my project important

\section{Temporal Logic}
In this project, our correctness properties are expressed using a temporal logic, i.e., a modal logic which can be used to reason about time. All of the logics I will discuss are based on Linear Temporal Logic.

%TODO more words

\subsection{Linear Temporal Logic}
Linear Temporal Logic (LTL)\autocite{pnueli1977temporal} is a temporal logic created for model checking. It's syntax and semantics follow. Assume that we have an infinite supply of propositional variables $a,b,c,\dots$.
\begin{defn}{LTL Syntax}

  An LTL formula $\varphi$ is inductively defined in as follows\footnote{In Bachus-Naur form}:
  \[\varphi ::= a ~|~ \bot ~|~ \neg \varphi ~|~\varphi \lor \varphi ~|~ \varphi \land \varphi ~|~ \bigcirc \varphi ~|~ \varphi \U\varphi\]
\end{defn}
\begin{notn}{LTL Abbreviations}

  The following standard abbreviations are made:
  \begin{align*}
    \top &:= \neg \bot\\
    \varphi \to \psi &:= \neg \varphi \lor \psi\\
    \varphi \leftrightarrow \psi &:= (\varphi \to \psi) \land (\psi \to \varphi)\\
    \Diamond \varphi &:= \top \U{} \varphi\\
    \Box \varphi &:= \neg\Diamond\neg\varphi
  \end{align*}
\end{notn}

We read $\top$ as `true', $\bot$ as `false', $\bigcirc$ as `next', $\Diamond$ as `eventually', $\Box$ as `always', and $\U$ as `until'.

The formulae of LTL are interpreted over sequences of states called traces.

\begin{defn}{Traces and states}

  Let $P$ be a set of propositional variables. A \emph{state} $\rho_i \subseteq P$ is a set of propositional variables which are interpreted as true. A \emph{trace} $\sigma \in P^+$ is an infinite sequence of states.
\end{defn}

\begin{notn}
Let $\sigma$ be a sequence, then $\sigma_i$ is the $i$th state in $\sigma$, $\sigma^i$ is $\sigma$ with the first $i$ elements removed, and $\epsilon$ is the empty sequence.
\end{notn}

\begin{defn}{LTL Semantics}

  Let $P$ be a set of propositional variables and $\sigma$ a trace. The satisfaction relation $\vDash_{L}$ is inductively defined as follows:
\begin{align*}
  \sigma &\vDash_{L} a \iff a \in \sigma_0\\
  \sigma &\nvDash_{L} \bot\\
  \sigma &\vDash_{L} \neg \varphi \iff \sigma \nvDash_{L} \varphi\\
  \sigma &\vDash_{L} \varphi \lor \psi \iff \sigma \vDash_{L} \varphi \tor \sigma \vDash_{L} \psi\\
  \sigma &\vDash_{L} \varphi \land \psi \iff \sigma \vDash_{L} \varphi \tand \sigma \vDash_{L} \psi\\
  \sigma &\vDash_{L} \bigcirc \varphi \iff \sigma^1 \vDash_{L} \varphi\\
  \sigma &\vDash_{L} \varphi \U \psi \iff \sigma^i \vDash_{L} \psi \fsome i \geq 0 \tand \sigma^j \vDash_{L} \varphi \fall 0 \leq j < i
\end{align*}

\end{defn}

\begin{lem}{Expansion laws}

  In LTL, the following equivalences hold:
  \begin{align}
    \Box \varphi &\equiv \varphi \land \bigcirc \Box \varphi\\
    \Diamond \varphi &\equiv \varphi \lor \bigcirc \Diamond \varphi\\
    \psi \U \varphi &\equiv \varphi \lor \bigcirc \psi \U \varphi
  \end{align}

\end{lem}

%TODO Examples


\subsection{Finite LTL}
For runtime verification, we are generally concerned with finite traces. Since LTL and TPTL are both defined over infinite traces, a modification of the semantics is necessary to apply them to runtime verification problems. %TODO give good reasons
There are several variations of finite LTL semantics, I will consider Infinite Extension LTL (IE-LTL)\autocite{rosu2005rewriting}, RV-LTL\autocite{bauer2010comparing} and the two logics which RV-LTL is based upon, FLTL and LTL$_3$\autocite{bauer2010comparing}.
Assume that each trace $\sigma$ in this section is finite.

\paragraph{IE-LTL} The idea behind IE-LTL is to assume that the final state of a trace repeats forever. For IE-LTL, the only difference in the semantics is in the final state.
\begin{defn}{IE-LTL semantics}

  Let $\sigma_f$ be the final state of the trace. Given the usual LTL semantics, add the following:
  \begin{align*}
    \sigma_f &\vDash_{IE} \bigcirc \varphi \iff \sigma_f \vDash_{IE} \varphi\\
    \sigma_f &\vDash_{IE} \varphi \U \psi \iff \sigma_f \vDash_{IE} \psi
  \end{align*}
\end{defn}

\newcommand{\sn}{\bigcirc^+}
\newcommand{\wn}{\bigcirc^-}

\paragraph{FLTL} For FLTL, the next operator of LTL is split into a weak ($\wn$) and strong ($\sn$) version.
The strong next requires the existence of a next state to be true, while the weak next operator is vacuously true if there is no next state.
Thus, in the final state, the weak operator evaluates to true, and the strong next to false. The strong and weak next operators are dual of each other, with  $\neg\sn\varphi \equiv \wn\neg\varphi$.
\begin{defn}{FLTL semantics}

  Given the standard LTL semantics, replace the rule for the next operator with:
  \begin{align*}
    \sigma&\vDash_F\sn\varphi \iff \sigma^1\vDash_F\varphi \tand \sigma^1 \neq \epsilon\\
    \sigma&\vDash_F\wn\varphi \iff \sigma^1\vDash_F\varphi \tor \sigma^1 = \epsilon
  \end{align*}
\end{defn}

\begin{lem}

  In FLTL, the expansion laws become:
  \begin{align}
    \Box \varphi \equiv \varphi \land \wn \Box \varphi \label{fltl-el1}\\
    \Diamond \varphi \equiv \varphi \lor \sn \Diamond \varphi\\
    \psi \U \varphi \equiv \varphi \lor \sn \psi \U \varphi
  \end{align}

\end{lem}

\begin{proof}
  From \autocite{bauer2010comparing}.
  %Bauer 5.3
\end{proof}

\newcommand{\ltlt}{LTL$_3$}
\paragraph{\ltlt} In \ltlt, a new truth value is introduced to represent uncertainty.
\begin{defn}{\ltlt\ semantics}

  The semantics for \ltlt\ are defined by cases relying on standard LTL semantics. The notation $\sigma\gamma$ refers to the concatenation of the infinite trace $\gamma$ to the finite trace $\sigma$.
  \[\sigma\vDash_3\varphi =
    \begin{cases}
      \top & \text{if } \sigma\gamma \vDash_L \fall \gamma \in P^+\\
      \bot & \text{if } \sigma\gamma \vDash_L \fall \gamma \in P^+\\
      ? & \text{otherwise}
    \end{cases}
    \]
\end{defn}

\paragraph{RV-LTL} RV-LTL is based on FLTL and \ltlt.
\begin{defn}{RV-LTL semantics}

  The semantics for RV-LTL are also defined by cases.
  \[\sigma\vDash_{RV}\varphi =
    \begin{cases}
      \top & \text{if } \sigma \vDash_3 \varphi = \top\\
      \bot & \text{if } \sigma \vDash_3 \varphi = \bot\\
      \top^P & \text{if } \sigma \vDash_3 \varphi = ~?\tand \sigma\vDash_F = \top \\
      \bot^P & \text{if } \sigma \vDash_3 \varphi = ~?\tand \sigma\vDash_F = \bot \\

    \end{cases}
  \]
\end{defn}


\subsection{Timed Propositional Temporal Logic}
Timed Propositional Temporal Logic (TPTL)\autocite{alur1994really} is an extension of LTL to encode explicit time into the logic. In LTL, only the order of states is reasoned about, i.e., $\sigma_i$ is before $\sigma_{i+1}$, but for many verification problems it can be useful to reason about the explicit time at which a state occurs, i.e., $\sigma_i$ is 3 time units earlier than $\sigma_{i+1}$. For this we define a time trace which contains the sequence of times corresponding to the sequence of states. A quantifier called a \emph{freeze operator} is added to the logic, which binds occurrences of a variable to the time at which the operator is evaluated. Integer comparison is added to the logic, to allow for specifications such as: ``If $p$ becomes true, $q$ will become true within 5 time units".


\begin{defn}{Timed Trace}

  A Timed Trace $\rho = (\sigma,\tau)$ is a pair of a trace (state sequence) $\sigma \in P^+$ and a time sequence $\tau \in \mathbb{N}^+$ which is a sequence of non-negative integers that is monotonically non-decreasing ($\forall i. ~\tau_i \leq \tau_{i+1}$) and eventually always increasing ($\forall i. \exists j. ~\tau_i < \tau_j$).
\end{defn}

Assume there exist an infinite supply of time variables  and let $V=\{x,y,z...\}$ be the set of these variables.

\begin{defn}{TPTL Syntax}
  Let $a\in P$ be a propositional variable, $x\in V$ be a time variable and $c\in\mathbb{N}$ a constant.

  TPTL terms $\pi$ and formulas $\varphi$ are inductively defined as follows:
  \begin{align*}
    \pi &::= x + c ~|~ c\\
    \varphi &::= a ~|~ \pi \leq \pi ~|~ \bot ~|~ \neg \varphi ~|~\varphi \lor \varphi ~|~ \varphi \land \varphi ~|~ \bigcirc \varphi ~|~ \varphi \U \varphi ~|~ x. \varphi
  \end{align*}
\end{defn}

\begin{notn}{Abbreviations}

  TPTL has the same abbreviations as LTL, plus abbreviations for comparison operations between terms such as $\pi_1 < \pi_2 := \pi_1 \leq \pi_2 \land \neg(\pi_2 \leq \pi_1)$, and so on as expected for $>,\geq,=,\neq$.
\end{notn}

\begin{defn}{TPTL Semantics}
  \newcommand{\eval}{\mathcal{E}}

  Let $\rho = (\sigma,\tau)$ be a time trace, $x\in V$, $c\in\mathbb{N}$, and let $\eval:V\to\mathbb{N}$ be a evaluation of time variables to times, with $\eval(x + c) = \eval(x) + c$, $\eval(c) = c$ and $\eval[x:=c]$ denoting the evaluation which agrees with $\eval$ for $V\setminus\{x\}$ and maps $x$ to $c$.
  TPTL uses the same semantics as LTL for those operators which overlap with LTL, except the relation is defined over a time trace rather than a standard trace. For those cases, substitute occurrences of $\sigma\vDash_{LTL}\cdots$ with $\rho\vDash_{T,\eval}\cdots$. The remainder of the definition is as follows:
  \begin{align*}
    \rho&\vDash_{T,\eval}\pi_1\leq\pi_2 \iff \eval(\pi_1)\leq\eval(\pi_2)\\
    \rho&\vDash_{T,\eval} x.\varphi \iff \rho\vDash_{T,\eval[x:=\tau_0]}\varphi
  \end{align*}
\end{defn}

%TODO examples of specifications
\subsection{Finite TPTL}
\paragraph{RV-TPTL}
\section{Runtime Verification using Formula Rewriting}
\section{Implementation in Scala}
%shallow embedding / internal DSL ref TraceContract

\section{Discussion}
\subsection{Future Work}
\section{Conclusion}
\subsection{Acknowledgements}

\nocite{*}
\printbibliography{}
\newpage
\section{Appendix}\label{appendix}

\end{document}
